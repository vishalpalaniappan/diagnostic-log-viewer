import clpFfiJsModuleInit from "clp-ffi-js";

import CDL_WORKER_PROTOCOL from "../CDL_WORKER_PROTOCOL";
import {readFile} from "../helper/ReadFile";
import ThreadDebugger from "./ThreadDebugger";
import CdlHeader from "./CdlHeader";
import Thread from "./Thread";

/**
 * This class accepts a CDL file object and allows you to
 * interact with all the threads.
 */
class Debugger {
    /**
     * Loads the CDL file and initializes the debugger state.
     * @param {File|String} cdlFile File object or URL of CDL log file.
     * @param {Number} executionIndex
     */
    constructor (cdlFile, executionIndex) {
        readFile(cdlFile).then(async (data) => {
            const Module = await clpFfiJsModuleInit();
            const decoder = new Module.ClpStreamReader(data, {
                timestampKey: {isAutoGenerated: true, parts: ["timestamp", "unix_millisecs"]},
                logLevelKey: {isAutoGenerated: true, parts: ["level", "name"]}}
            );
            const log = decoder.decodeRange(0, decoder.deserializeStream(), false);

            this.parseLogAndInitializeDebugger(log);

            executionIndex = 1;

            const currThread = this.masterList[1].threadId;
            const pos = this.masterList[1].position - 1;

            this.debuggers[currThread].thread.getPositionData(pos);

            // if (executionIndex) {
            //     if (executionIndex < 0 || executionIndex >= this.cdl.execution.length) {
            //         console.debug("The provided execution index is out of bounds.");
            //         console.debug("Going to end of the program.");
            //         this.replayProgram();
            //     } else {
            //         this.cdl.getPositionData(executionIndex);
            //     }
            // } else {
            //     this.cdl.getPositionData(this.cdl.currPosition);
            // }
        });
    }

    /**
     * This function parses the CDL log file and intializes the debugger state.
     * @param {Array} logFile Contents of decompressed CDL log file.
     */
    parseLogAndInitializeDebugger (logFile) {
        this.threads = {};
        this.debuggers = {};
        this.masterList = [];

        const headerLog = JSON.parse(logFile[0][0]);
        const headerInfo = JSON.parse(headerLog["user-generated"]["header"]);
        this.header = new CdlHeader(headerInfo);

        // Group all thread execution into its own key
        let position = 1;
        do {
            const log = JSON.parse(logFile[position][0]);
            const threadId = log["user-generated"]["thread"];
            if (!(threadId in this.threads)) {
                this.threads[threadId] = [headerLog];
            }
            this.threads[threadId].push(log);

            this.masterList.push({
                "threadId": threadId,
                "position": this.threads[threadId].length - 1,
                "log": log,
            });
        } while (++position < logFile.length);

        // For each thread, create a new CDL instance
        Object.keys(this.threads).forEach((threadId, index) => {
            this.debuggers[threadId] = new ThreadDebugger(this.threads[threadId], threadId);
        });

        this.currentThread = Object.keys(this.threads)[0];
        this.cdl = this.debuggers[Object.keys(this.threads)[0]];
        this.breakpoints = [];

        console.info(this.cdl);
        console.info(this.debuggers);

        postMessage({
            code: CDL_WORKER_PROTOCOL.GET_METADATA,
            args: {
                fileTree: this.header.getSourceFiles(),
            },
        });
    }

    /**
     * This function returns the variable stack at a given position.
     * @param {Number} position
     * @param {String} threadId
     */
    getVariableStack (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.getVariableStack(position);
    }

    /**
     * This function moves to the start of the file.
     */
    goToStart () {
        const startThread = this.masterList[0].threadId;
        const threadDebugger = this.debuggers[startThread];
        threadDebugger.getPositionData(threadDebugger.thread.firstStatement);
    }

    /**
     * This function moves to the end of the file.
     */
    goToEnd () {
        this.cdl.getPositionData(this.cdl.lastStatement);
    }

    /**
     * This function steps into the next position.
     * @param {Number} position
     * @param {String} threadId
     */
    stepInto (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepInto(position);
    }

    /**
     * This function steps out of the current position.
     * @param {Number} position
     * @param {String} threadId
     */
    stepOut (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepOut(position);
    }

    /**
     * This function steps over any function calls.
     * @param {Number} position
     * @param {String} threadId
     */
    stepOverForward (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepOverForward(position);
    }

    /**
     * This function steps over any function calls backwards.
     * @param {Number} position
     * @param {String} threadId
     */
    stepOverBackward (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepOverBackward(position);
    }

    /**
     * Play the program from the start.
     * @param {Number} position
     */
    replayProgram (position) {
        this.playForward(0);
    }


    /**
     * Given a position in a thread, this function returns the position
     * in the master list.
     * @param {Number} threadPos
     * @param {String} threadId
     * @return {Number|null}
     */
    getMasterPosFromThreadPos (threadPos, threadId) {
        let position = 0;
        do {
            const masterLog = this.masterList[position];

            const currThreadPos = masterLog.position;
            const currThreadId = masterLog.threadId;

            if (currThreadId == threadId && currThreadPos == threadPos) {
                return position;
            }
        } while (position++ < this.masterList.length);

        return null;
    }

    /**
     * Play the program forward from the given position.
     * @param {Number} position
     * @param {String} threadId
     */
    playForward (position, threadId) {
        let masterPosition = this.getMasterPosFromThreadPos(position, threadId);
        do {
            masterPosition++;
            const masterLog = this.masterList[masterPosition];

            const currThreadPos = masterLog.position;
            const currThreadId = masterLog.threadId;
            const currLog = masterLog.log;

            const type = currLog["user-generated"]["type"];

            if (type == "adli_execution") {
                const lt = currLog["user-generated"]["value"];
                for (const breakpoint of this.breakpoints) {
                    if (breakpoint.enabled && breakpoint.id === lt) {
                        this.debuggers[currThreadId].thread.getPositionData(currThreadPos);
                        return;
                    }
                };
            };
        } while (masterPosition < this.masterList.length);
    }

    /**
     * Play the program backward from the given position.
     * @param {Number} position
     * @param {String} threadId
     */
    playBackward (position, threadId) {
        let masterPosition = this.getMasterPosFromThreadPos(position, threadId);
        do {
            masterPosition--;
            const masterLog = this.masterList[masterPosition];

            const currThreadPos = masterLog.position;
            const currThreadId = masterLog.threadId;
            const currLog = masterLog.log;

            const type = currLog["user-generated"]["type"];

            if (type == "adli_execution") {
                const lt = currLog["user-generated"]["value"];
                for (const breakpoint of this.breakpoints) {
                    if (breakpoint.enabled && breakpoint.id === lt) {
                        this.debuggers[currThreadId].thread.getPositionData(currThreadPos);
                        return;
                    }
                };
            };
        } while (masterPosition < this.masterList.length);
    }

    /**
     * Toggles the breakpoint at the given filename and line number.
     * @param {String} fileName
     * @param {Number} lineNumber
     */
    toggleBreakpoint (fileName, lineNumber) {
        const lt = this.header.getLogTypeFromLineNumber(fileName, lineNumber);

        if (lt === null) {
            return;
        }

        if (this.breakpoints.includes(lt)) {
            this.breakpoints.splice(this.breakpoints.indexOf(lt), 1);
        } else {
            lt.enabled = true;
            this.breakpoints.push(lt);
        }

        postMessage({
            code: CDL_WORKER_PROTOCOL.BREAKPOINTS,
            args: {
                breakpoints: this.breakpoints,
            },
        });
    }

    /**
     * Enables/Disables the breakpoint given a fileName and lineNumber.
     * @param {String} fileName
     * @param {Number} lineNumber
     */
    toggleBreakpointEnabled (fileName, lineNumber) {
        const lt = this.header.getLogTypeFromLineNumber(fileName, lineNumber);
        if (lt === null) {
            console.warn("Breakpoint not found");
            return;
        }

        const index = this.breakpoints.indexOf(lt);
        if (index === -1) {
            console.warn("Breakpoint not in active breakpoints list");
            return;
        }

        this.breakpoints[index].enabled = !this.breakpoints[index].enabled;

        postMessage({
            code: CDL_WORKER_PROTOCOL.BREAKPOINTS,
            args: {
                breakpoints: this.breakpoints,
            },
        });
    }
}

export default Debugger;

import clpFfiJsModuleInit from "clp-ffi-js";

import CDL_WORKER_PROTOCOL from "../CDL_WORKER_PROTOCOL";
import {readFile} from "../helper/ReadFile";
import CdlHeader from "./CdlHeader";
import ThreadDebugger from "./ThreadDebugger";

/**
 * This class accepts a CDL file object and allows you to
 * interact with all the threads.
 */
class Debugger {
    /**
     * Loads the CDL file and initializes the debugger state.
     * @param {File|String} cdlFile File object or URL of CDL log file.
     * @param {Number} executionIndex
     */
    constructor (cdlFile, executionIndex) {
        readFile(cdlFile).then(async (data) => {
            const Module = await clpFfiJsModuleInit();
            const decoder = new Module.ClpStreamReader(data, {
                timestampKey: {isAutoGenerated: true, parts: ["timestamp", "unix_millisecs"]},
                logLevelKey: {isAutoGenerated: true, parts: ["level", "name"]}}
            );
            const log = decoder.decodeRange(0, decoder.deserializeStream(), false);

            this.parseLogAndInitializeDebugger(log);

            if (executionIndex) {
                if (executionIndex < 0 || executionIndex >= log.length) {
                    console.debug("The provided execution index is out of bounds.");
                    console.debug("Going to end of the program.");
                    this.replayProgram();
                } else {
                    const currThread = this.masterList[executionIndex].threadId;
                    const pos = this.masterList[executionIndex].position - 1;
                    this.debuggers[currThread].thread.getPositionData(pos);
                }
            } else {
                this.replayProgram();
            }
        });
    }

    /**
     * This function parses the CDL log file and intializes the debugger state.
     * @param {Array} logFile Contents of decompressed CDL log file.
     */
    parseLogAndInitializeDebugger (logFile) {
        this.threads = {};
        this.debuggers = {};
        this.masterList = [];

        const headerLog = JSON.parse(logFile[0][0]);
        const headerInfo = headerLog["user-generated"]["header"];
        this.header = new CdlHeader(headerInfo);
        this.firstThread = null;

        // Group all thread execution into its own key
        let position = 1;
        do {
            const log = JSON.parse(logFile[position][0]);
            const threadId = log["user-generated"]["thread"];
            if (!(threadId in this.threads)) {
                this.threads[threadId] = [headerLog];
            }
            this.threads[threadId].push(log);

            this.masterList.push({
                "threadId": threadId,
                "position": this.threads[threadId].length - 1,
                "log": log,
            });

            // Save first thread
            if (this.firstThread == null) {
                this.firstThread = threadId;
            }

            // Save last thread
            this.lastThread = threadId;
        } while (++position < logFile.length);

        // For each thread, create a new debugger
        Object.keys(this.threads).forEach((threadId, index) => {
            this.debuggers[threadId] = new ThreadDebugger(this.threads[threadId], threadId);
        });

        this.currentThread = Object.keys(this.threads)[0];
        this.cdl = this.debuggers[this.currentThread];
        this.breakpoints = [];

        console.info(this.cdl);
        console.info(this.debuggers);

        postMessage({
            code: CDL_WORKER_PROTOCOL.GET_METADATA,
            args: {
                fileTree: this.header.getSourceFiles(),
            },
        });

        this.sendExecutionTree();
    }

    /**
     * Given a position in a thread, this function returns the position
     * in the master list.
     * @param {Number} threadPos
     * @param {String} threadId
     * @return {Number|null}
     */
    getMasterPosFromThreadPos (threadPos, threadId) {
        let position = 0;
        do {
            const masterLog = this.masterList[position];

            const currThreadPos = masterLog.position;
            const currThreadId = String(masterLog.threadId);

            if (currThreadId == String(threadId) && currThreadPos == threadPos) {
                return position;
            }
        } while (++position < this.masterList.length);

        return null;
    }

    /**
     * This function sends the stack information for
     * each thread to the front end.
     * @param {String} currentThread
     */
    sendStackInformation (currentThread) {
        const threadIds = Object.keys(this.debuggers);
        const threadPos = this.debuggers[currentThread].position;
        const stackInfo = {};
        let masterPos = this.getMasterPosFromThreadPos(threadPos, currentThread);

        // Set the last executed position in each of the debuggers
        do {
            const current = this.masterList[masterPos];
            const type = current.log["user-generated"]["type"];
            const thread = String(current.log["user-generated"]["thread"]);

            if (type === "adli_execution" && threadIds.includes(thread)) {
                this.debuggers[thread].position = current.position;
                threadIds.splice(threadIds.indexOf(thread), 1);
                stackInfo[thread] = {
                    main: thread == currentThread,
                    stack: this.debuggers[thread].getStack(),
                };
            }
            masterPos--;
        } while (masterPos > 0 && threadIds.length > 0);

        postMessage({
            code: CDL_WORKER_PROTOCOL.GET_POSITION_DATA,
            args: stackInfo,
        });
    }

    /**
     * This function sends the execution tree to be visualized.
     */
    sendExecutionTree () {
        for (const thread in this.debuggers) {
            if (thread) {
                const instance = this.debuggers[thread];
                if (instance.thread.executionTree) {
                    postMessage({
                        code: CDL_WORKER_PROTOCOL.GET_EXECUTION_TREE,
                        args: instance.thread.executionTree,
                    });
                    break;
                }
            }
        }
    }

    /**
     * This function returns the variable stack at a given position.
     * @param {Number} position
     * @param {String} threadId
     */
    getVariableStack (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        const [localVars, globalVars] = threadDebugger.getVariables(position);
        postMessage({
            code: CDL_WORKER_PROTOCOL.GET_VARIABLE_STACK,
            args: {
                localVariables: localVars,
                globalVariables: globalVars,
            },
        });
    }

    /**
     * This function moves to the start of the file.
     */
    goToStart () {
        const threadDebugger = this.debuggers[this.firstThread];
        threadDebugger.position = threadDebugger.thread.firstStatement;
        this.sendStackInformation(this.firstThread);
    }

    /**
     * This function moves to the end of the file.
     */
    goToEnd () {
        const threadDebugger = this.debuggers[this.lastThread];
        threadDebugger.position = threadDebugger.thread.lastStatement;
        this.sendStackInformation(this.lastThread);
    }

    /**
     * This function steps into the next position.
     * @param {Number} position
     * @param {String} threadId
     */
    stepInto (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepInto(position);
        this.sendStackInformation(threadId);
    }

    /**
     * This function steps out of the current position.
     * @param {Number} position
     * @param {String} threadId
     */
    stepOut (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepOut(position);
        this.sendStackInformation(threadId);
    }

    /**
     * This function steps over any function calls.
     * @param {Number} position
     * @param {String} threadId
     */
    stepOverForward (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepOverForward(position);
        this.sendStackInformation(threadId);
    }

    /**
     * This function steps over any function calls backwards.
     * @param {Number} position
     * @param {String} threadId
     */
    stepOverBackward (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.stepOverBackward(position);
        this.sendStackInformation(threadId);
    }

    /**
     * This function goes to the provided position in the thread.
     * @param {Number} position
     * @param {String} threadId
     */
    goToPosition (position, threadId) {
        const threadDebugger = this.debuggers[threadId];
        threadDebugger.goToPosition(position);
        this.sendStackInformation(threadId);
    }

    /**
     * Play the program from the start.
     * @param {Number} position
     */
    replayProgram () {
        this.playForward(0, this.firstThread);
    }

    /**
     * Play the program forward from the given position.
     * @param {Number} position
     * @param {String} threadId
     */
    playForward (position, threadId) {
        let masterPosition = this.getMasterPosFromThreadPos(position, threadId);

        // We are already at end of the file.
        if (masterPosition == this.masterList.length - 1) {
            return;
        }

        do {
            masterPosition++;
            const masterLog = this.masterList[masterPosition];

            const currThreadPos = masterLog.position;
            const currThreadId = masterLog.threadId;
            const currLog = masterLog.log;
            const currentDebugger = this.debuggers[currThreadId];

            const type = currLog["user-generated"]["type"];

            if (type == "adli_execution") {
                const lt = currLog["user-generated"]["value"];
                for (const breakpoint of this.breakpoints) {
                    if (breakpoint.enabled && breakpoint.id === lt) {
                        currentDebugger.position = currThreadPos;
                        this.sendStackInformation(currThreadId);
                        return;
                    }
                };
            };
        } while (masterPosition < this.masterList.length - 1);

        // Get the debugger of the thread which executed the last statement
        // in the master list and use that to go to end of the program.
        const lastDebugger = this.debuggers[this.lastThread];
        lastDebugger.goToEnd();
        this.sendStackInformation(this.lastThread);
    }

    /**
     * Play the program backward from the given position.
     * @param {Number} position
     * @param {String} threadId
     */
    playBackward (position, threadId) {
        let masterPosition = this.getMasterPosFromThreadPos(position, threadId);

        // We are already at the start of the file
        if (masterPosition == 0) {
            return;
        }

        do {
            masterPosition--;
            const masterLog = this.masterList[masterPosition];

            const currThreadPos = masterLog.position;
            const currThreadId = masterLog.threadId;
            const currLog = masterLog.log;
            const currentDebugger = this.debuggers[currThreadId];

            const type = currLog["user-generated"]["type"];

            if (type == "adli_execution") {
                const lt = currLog["user-generated"]["value"];
                for (const breakpoint of this.breakpoints) {
                    if (breakpoint.enabled && breakpoint.id === lt) {
                        currentDebugger.position = currThreadPos;
                        this.sendStackInformation(currThreadId);
                        return;
                    }
                };
            };
        } while (masterPosition > 0);

        // Get the debugger of the thread which executed the first statement
        // in the master list and use that to go to the start of the program.
        const firstDebugger = this.debuggers[this.firstThread];
        firstDebugger.goToStart();
        this.sendStackInformation(this.firstThread);
    }

    /**
     * Toggles the breakpoint at the given filename and line number.
     * @param {String} fileName
     * @param {Number} lineNumber
     */
    toggleBreakpoint (fileName, lineNumber) {
        const lt = this.header.getLogTypeFromLineNumber(fileName, lineNumber);

        if (lt === null) {
            return;
        }

        if (this.breakpoints.includes(lt)) {
            this.breakpoints.splice(this.breakpoints.indexOf(lt), 1);
        } else {
            lt.enabled = true;
            this.breakpoints.push(lt);
        }

        postMessage({
            code: CDL_WORKER_PROTOCOL.BREAKPOINTS,
            args: {
                breakpoints: this.breakpoints,
            },
        });
    }

    /**
     * Enables/Disables the breakpoint given a fileName and lineNumber.
     * @param {String} fileName
     * @param {Number} lineNumber
     */
    toggleBreakpointEnabled (fileName, lineNumber) {
        const lt = this.header.getLogTypeFromLineNumber(fileName, lineNumber);
        if (lt === null) {
            console.warn("Breakpoint not found");
            return;
        }

        const index = this.breakpoints.indexOf(lt);
        if (index === -1) {
            console.warn("Breakpoint not in active breakpoints list");
            return;
        }

        this.breakpoints[index].enabled = !this.breakpoints[index].enabled;

        postMessage({
            code: CDL_WORKER_PROTOCOL.BREAKPOINTS,
            args: {
                breakpoints: this.breakpoints,
            },
        });
    }
}

export default Debugger;
